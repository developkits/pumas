\documentclass[a4paper,11pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[top=3cm,left=2.5cm,right=2.5cm,bottom=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage{sidecap}
\usepackage{theorem}
\usepackage{thc}
\usepackage{url}
\usepackage{epsfig}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[floatrow]{chemstyle}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{pbox}
\usepackage{cite}
\usepackage{titlesec}
\usepackage[makeroom]{cancel}
\include{header}
\usepackage{indentfirst}



\long\def\symbolfootnote[#1]#2{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}

\geometry{ bottom=2 cm}


\setlength{\abovecaptionskip}{-10pt plus 3pt minus 2pt}


\setlength{\headheight}{15pt}

\fancyhf{}
\fancyhead[RO,LE]{\footnotesize{\leftmark}}
\fancyhead[LO,RE]{\thepage}

\pagestyle{fancy}

\renewcommand\maketitle{
\begin{titlepage}

 \begin{center}
 \begin{figure}[htpb]
\rule{1 \textwidth}{1pt}\\
 \smallskip  
 \end{figure}

\vfill

\textbf{ \begin{huge}
Developing a Predator Prey Simulation
\end{huge}}

\vspace{0.4cm}

\begin{Large}
 \textit{Programming Skills}
\end{Large}

\vspace{1cm}


\begin{tabular}{ccc}
\large{Diamantis Dakaris, Ewen Lawson Gillies, Michal Kawalec, Claude Schmidt} \vspace{0.15cm}\\
\large{\textit{University of Edinburgh, UK}}\\
\end{tabular}




  
\vspace{0.7cm}
\large{Something here?}\\
\vspace{0.7cm}
\includegraphics[width=0.33\textwidth]{edinburgh_crest.jpg}\\
\vspace{0.7cm}
\Large{7th of November 2013}

\end{center}

\vfill

\begin{abstract}

The aim of this project is to develop the essential programming skills through a group project 

\end{abstract}


\vfill


  \begin{center}
 \rule{1 \textwidth}{1pt}\\
 \end{center}



\end{titlepage}}

\begin{document}

\maketitle
\tableofcontents
\newpage
\setcounter{page}{1}



\section{Introduction}
The focus of this project was to apply the skills acquired in class to develop a Predator-Prey simulation in a group setting.  This group opted write the program in \texttt{C++}.  In order to do so, the project members started with a rough outline of the program.  From here, development tasks were assigned to each member.  The revision control software $\texttt{git}$ was used to streamline the collaborative efforts of the group.  Once a working simulation was written, it was thoroughly tested, debugged, and improved.  The resulting simulation includes several output types for different visualization programs.  

For reference, the coupled partial differential equations that dictate the time evolution of the populations of pumas and hares are included below.  $H$ is the population of hares, $P$ is the population of pumas, $x,y,$ and $t$ are space and time coordinates respectively, and $r,a,k,b,m$ and $l$ are scaling parameters, as discussion in Section \ref{params}.

\begin{equation}\label{hares}
\pd{H}{t} = rH - aHP +k\left(\pdd{H}{x} + \pdd{H}{y}\right)
\end{equation}

\begin{equation}\label{pumas}
\pd{P}{t} = bHP - mP +l\left(\pdd{P}{x} + \pdd{P}{y}\right)
\end{equation}

\section{Group Coordination}

As with any software development, the planning played a big role in the final product.  Through regular meetings, emails, task management websites, and revision control repositories, plans were set and efforts were coordinated to ensure an efficient and productive group effort.  

\subsection{Group Members Responsibilities}

In order to increase efficiency and productivity, the division of labour was determined very early on.  This division was based primarily on the existing skills set of each member.  Each member was mandated to some of the coding. The more experienced coders edited the work of the less experienced once in a hierarchical order. The most experienced then explained his reasoning to the rest of the group, giving them an opportunity for further input into the final code.  This ensured both an optimal simulation, learning experience, and supportive feedback for each member.  The breakdown of the tasks and responsibilities for each member in order of coding previous experience in $\texttt{C++}$ are as follows.
\\

\noindent\textbf{Michal Kawalec:}  Due to his experience in software development and project management, Michal set up the structure of the simulation and submitted this structure to a repository on \url{https://github.com/mkawalec/pumas}.  This structure included the header files and source files appropriately formatted with empty functions as well as the build system configuration. Michal also conducted all final edits, adapting the other members ideas to the optimal syntax.
\\

\noindent\textbf{Claude  Schmidt:}   With a strong working understanding of $\texttt{C++}$, Claude was tasked with writing the first draft of the constructor, as well as (OTHER STUFF).  He also provided the group with the structure and planning needed for optimal time management.  
\\

\noindent{\textbf{Ewen Gillies:}  Given his experience in numerical solutions to partial differential equations, Ewen was tasked with writing the integrating function and dealing with the boundary cells.  Since he lacked experience in $\texttt{C++}$, any additional structural ideas ideas were relayed to the more experience coders for optimal syntax.  He then reviewed this code to ensure all ideas were properly expressed.  Additionally, he was tasked with compiling the group report.
\\

\noindent{\textbf{Diamantis Dakaris:}}  Using his strong mathematical background, Diamantis conducted the preliminary analysis of the equation at hand, as well as the intermediate and final analysis of the output.  He also wrote the initial output function, which was then extrapolated to the final one.  As a relatively inexperienced coder, Diamantis was able to offer effective continual feedback on readability and the logical structure of the code, ensuring that all levels of coders would be able to read code and reproduce the results.  He also generated several of the input land maps for the simulation.

\subsection{Coordination}

The main method of group coordination and planning was through regular meetings.  
Full group meetings were held at least once per week, where new ideas and current progress could be discussed.  
During these meetings, smaller meetings between two or three members were organized where code would be peer edited or written by several members at once.

The members of the group agreed to use \texttt{Trello}\footnote{This tool is found at: \url{https://www.trello.com}} in order to ensure flexibility in task assignment and adaptability in the testing and debugging phases.  
This tool consists of four communal lists that each person can edit.  
These lists include \emph{To Do, Review, Doing,} and \emph{Done. }
By adding items to the to do list, shifting them to doing, and placing them in done, group efforts were easily and effective coordinated without any overlap.

\section{Design} 

This simulation has three major comments: Input, Simulation, and Output.  
It is designed to accept an ASCII file that determines the land map of the simulation.
The parameters that dictate the time evolution of the hare and puma populations can also be adjusted, although default values are provided.  
The simulation is then initialized, run for a set amount of time steps, and properly finalised.  
A a regular interval of time steps, the population of hares and pumas is printed to an output file using one of the available output methods.  
These outputs can then be visualized, plotted, and analyzed.

\subsection{Input}

The simulation must read in an input land map.  
This land map represents the two dimensional surface on which the simulation takes place.  
This surface can either be land, where hare and puma populations are allowed, or water, where they do not exist.  
The user has the option of setting the parameters that dictate the dynamics of the system as well, although default values are automatically provided.  
The land map and all input parameters are initially parsed by \texttt{solver.cpp}.

\subsubsection{Parameters}\label{params}

The input parameters can be set by the user, otherwise the default values are automatically initialized.  
These parameters are divided into four categories: generic options, simulation parameters, simulation options, and input/output options.
The generic options include displaying a help menu and the version of the simulation.  
The simulation parameters include the scaling factors of the terms in the coupled partial differential equations \eqref{hares} and \eqref{pumas}.  
The simulation options include the size of the time step, the frequency of the output, and the time at which the simulation ends.  
The input/output options include the output names, extensions, and formats as well as the frequency at which the progress of the simulation is printed to the terminal.  

All of the parameters are set using the \texttt{boost/program\_options} library, using the traditional syntax. 
See Section~\ref{syntax} for an example.~\ref{tb:parameters}, below, contains a list of the simulation parameters and their default values. 
Note that shorthand parameters can be combined, so parameter \texttt{-oa output} is a valid sequence.

Parameter sets other than the Generic options can be set from a configuration file. 
This format uses the same parameter names as the command line, with a slightly different syntax. 
For an example, please see the \texttt{contrib/example.cfg} in the supporting documents.

\begin{table}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Type} & \textbf{Name} & \textbf{Description} & \textbf{Default} \\ \hline
\multirow{2}{*}{\pbox{10cm}{Generic \\ Options}}
 & \texttt{-h, -{}-help} & Show help message & N/A \\
 & \texttt{-v, -{}-version} & Show program version & N/A \\ \hline
\multirow{6}{*}{\pbox{10cm}{Simulation \\ Parameters}} 
 & \texttt{-r, -{}-r} & Birth rate of hares & 0.08 \\
 & \texttt{-a, -{}-a} & Rate at which pumas eat hares & 0.04\\
 & \texttt{-b, -{}-b} & Birth rate of pumas per hare eaten & 0.02 \\
 & \texttt{-m, -{}-m} & Mortality rate of pumas & 0.06 \\ 
 & \texttt{-k, -{}-k} & Diffusion rate of hares  & 0.2 \\ 
 & \texttt{-l, -{}-l} & Diffusion rate of pumas & 0.2 \\ \hline
\multirow{3}{*}{\pbox{10cm}{Simulation \\ Options}} 
 & \texttt{-e, -{}-end-time} & End time & 1000 \\
 & \texttt{-{}-dt} & Time step & 0.01\\
 & \texttt{-p, -{}-print-every} & Iterations between output frames & 100\\ \hline
 \multirow{7}{*}{\pbox{10cm}{\ \\ \ \\ \ \\ Input/Output \\ Options}} 
 & \texttt{-d, -{}-data-file} & Location of parameters file & none \\
 & \texttt{-o, -{}-output} & Filename of the main output file & \texttt{output} \\
 & \texttt{-a, -{}-aux} & Filename of the auxiliary output file & none \\
 & \texttt{-f, -{}-output-format}  &  Format of the output& \texttt{vmd} \\
  & &  (\texttt{vmd, gnuplot, ppm})   &  \\ 
 & \texttt{-e, -{}-output-extension} & Overrides the output extension & none \\
 & \texttt{-n, -{}-notify-after} & Output frames between printing  & 30 \\
  & & progress to terminal.  &  \\ 
 & \texttt{--split-files} & Forces the serializer to print each & \texttt{false} \\ 
 & & time frame to a new file.  &  \\ \hline

\end{tabular}
\caption{A table of input parameters and their default values.}
\label{tb:parameters}
\end{table}

%MICHAL will add text input option for all input params.

\subsubsection{Land Map}

The surface is discretised to have an $x$ and $y$ dimension, denoted interchangeably as \texttt{size\_x}, \texttt{dim\_x} and \texttt{size\_y}, \texttt{dim\_y}.  These two parameters are defined in the first line of every land map input file, and read in during the \texttt{ PUMA::Simulator* initialize} function in \texttt{solver.cpp}.  The rest of the land map input file entries are either 1 or 0 to denoted land or water.  To ensure the file format reflects the geometry of the surface, each line has \texttt{size\_x} entires, while the whole file has \texttt{size\_y} lines. The land map is read into the program at start up by naming it in the terminal, as shown in Section \ref{syntax}.

These file maps can be generated in any way that respects the description above.  The ones included in the submission were generated using \texttt{Gimp}\footnote{This freely distributed software is available here: \url{http://www.gimp.org}}.  The advantage of using this program is it allows the user to draw the desired land map in black and white, and then outputs this file directly to the desired \texttt{ASCII} format, including the dimensions in the first line.  Likewise, arbitrary image files can be opened, changed to black and white, and outputted to the desired land map format.

  
%CLAUDE do you need to put in the first two lines by hand?

\subsubsection{Sample Input Syntax}\label{syntax}

All input parameters and files are set at program launch using the syntax \texttt{./solver -\{name\} \{value\} \emph{land\_map\_name}.dat}.  For example, the following line sets the birth rate of hares to 0.1 and the time step to 0.05, leaving the rest as default values, and reads in a file named \texttt{island.dat}.
%MICHAL Double check syntax

\vspace{5pt}
\noindent\texttt{./solver -r 0.1 -dt 0.05 island.txt}

\subsection{Simulation}

The structure of the simulation itself is straightforward.  \texttt{Simulator.cpp} contains the majority of the computation and simulation properties.  The \texttt{solver.cpp} file contains the main function, along with an input parameters parser and \texttt{Simulator} class instantiation.  The results of the simulation passed to \texttt{Serializer.cpp} for printing.  These results can then be visualized.  For more on in-depth discussion of output, see Section \ref{output}.

\subsubsection{Initialization}

The simulation starts by parsing all input parameters and the land map file in the \texttt{solver.cpp} class.  First, the land map input file accessed by the \texttt{initialize} function.  As per the input file format, the first two entires are used to define the dimensions of the simulation .  The rest of the entries are stored in the one dimensional boolean \texttt{land\_map} array which has ($\texttt{dim\_x} \times \texttt{dim\_y}$) elements.  In this array, a value of \texttt{true} corresponds to a land entry, whereas \texttt{false} corresponds to a water entry.  The function then constructs a \texttt{Simulator}, as defined in the \texttt{Simulator.cpp} file, with the appropriate dimensions and land/water entries.  

\subsubsection{Construction}

The \texttt{Simulator} constructor effectively starts by allocating enough memory for store the information of two subsequent time steps.  These states are  referred to as \texttt{current\_state} and \texttt{temp\_state}.  Using the \texttt{boost} library, they each defined as a \texttt{shared\_array}\footnote{See section (REF) for a discussion of \texttt{shared\_arrays}}} of \texttt{landscape} entries.  The \texttt{landscape} structure\footnote{This structure is defined in \texttt{\textbackslash include\textbackslash helper.hpp}} stores information about the cell including whether it is land or water, the hare population, and the puma population. The boolean \texttt{land\_map} array is copied on to both states.  The land cells in the \texttt{current\_state} are then given a random\footnote{The random number generator is seeded according to the start time to ensure unique results for each run.} population of hares and pumas between 0 and 5, whereas the water cells are set to 0.  All cells in the \texttt{temp\_state} are initialized to zero.

The simulation is built with default values for all parameters.  After the constructor is called, the \texttt{solver.cpp} class reads any user set values and sets the simulator values accordingly, including the output type.

\subsubsection{Calculation}

After declaring some output streams and initializing an \texttt{average\_densities} structure\footnote{This structure stores one double for average hare density and one for average puma density, as defined in \texttt{\textbackslash include\textbackslash helper.hpp}.}, the simulation moves into the main calculation loop.  This loop is defined to iterate the simulation from the initial time to the final time in the defined time-step increments.  Most of the work is done in the \texttt{apply\_step} function, as defined in \texttt{Simulator.cpp}.  

The  \texttt{apply\_step} function starts by switching the contents of the  \texttt{current\_state} and the \texttt{temp\_state}.  It then opens a loop through all the sites in the system.  If the site is a land cell, it counts the number of neighboring land cells for use in the discretized partial differential equations.  The values in \texttt{temp\_state} are used to calculate the updated populations according to equations \eqref{hares} and \eqref{pumas} (REF), which are then stored in \texttt{current\_state}.  These values have a minimum value of zero.  All water cells are skipped so that their populations remain at zero.
.  

A key part of the \texttt{apply\_step} function is that it accesses all cells through the \texttt{get\_cell} function.  For all defined cells on the map, it returns the value of the \texttt{temp\_state}, as expected.  For all cells outside the limits of the system, it returns the \texttt{halo\_cell} which was initialized in the constructor.  Since all cells outside the system are defined to have a zero population, this is a cost effective way of setting and changing the boundary conditions.

% In a sense yes, but the main point of get_cell is that it enables 
% very easy change in the boundary conditions - you just change the
% get_cell proxy. The space savings are diminishing with increasing
% map size, in in the UK case we are saving just 0.1%

After the system is moved forward one time step, the average populations across all land cells are calculated.  These averages are printed to the terminal every \texttt{n} frames with the total data passed to the serializer every \texttt{p} frames, as defined in \ref{tb:parameters}.

\subsection{Output}\label{output}

The output of the simulation is handled by the \texttt{Serializer.cpp} file.  This file defines three output formats, each with its own class.  One format is chosen as a parameter of the current simulation.  The main loop tells the \texttt{Simulator.cpp} class to print, which then passes all the information to the \texttt{Serializer.cpp} where it is properly formatted.   This is intended to maximize flexibility in adding, removing, and choosing available output formats.  Once the output file has been generated, it can be visualized using one of several visualizers.

\subsubsection{Serializer}

\texttt{Serializer.cpp} is designed to effectively handle the output file format and nothing else.  It defines a class for all available output format.  These classes are all named and pointed to using a list of pointers.  \texttt{Simulator.cpp} defines a pointer to a \texttt{Serializer.cpp} class called \texttt{current\_serializer}.  Strictly speaking, the simulator is initialized as pointing to nothing.  It is then set to point to the desired format class in \texttt{solver.cpp} via the \texttt{choose\_output\_method(}\emph{arg}\texttt{)} function.  This function checks its argument against the names of the formats pointed to in the list, returning the appropriate pointer in the event of a match.  If none match, then the program returns an error.  In the event that the function is never called, \texttt{Simulator.cpp} sets \texttt{current\_serializer} to point to the first pointer of the list of available serializers.  

Once the  \texttt{current\_serializer} is set, \texttt{Simulator.cpp}  knows to where pass all the output data.  In the main loop, \texttt{solver.cpp}  opens two out streams, which are then passed to the \texttt{Simulator::serialize} function.  This function passes these out streams, as well as the \texttt{current\_state} and dimensions of the system to the address of the \texttt{current\_serializer} pointer, which is a class defined in \texttt{Serializer.cpp}.  This class then handles all formatting, and prints the contents of the current state to the appropriate stream.

For the purposes of this simple simulation, this output method is over engineered.  Its true strength and simplicity is only realized when the simulation has more than one output type.  By including \texttt{Serializer.cpp}, the output method is adaptable, scaleable, and separates concerns.  Should a new format be needed, only \texttt{Serializer.cpp} and its header file need to be edited.  The motivation to include several output types was to test the outputs using several visualization methods.

\subsubsection{Visualisation}

A key part of any simulation is the ability to visualize the results.  This program has been configured to output file types usable for three visualization program. 

VMD: live animation pipe, output formats, "new molecule," file type, CPK, 0 bond radius,

GNUPLOT:

PPM:  imagemagick, convert, convert -h

\section{Tools and Frameworks}

Introduce this stuff

\subsection{Programming Language}

For this simulation, \texttt{C++11} was used as the primary programming language.  This is the most current version of \texttt{C++}.  With this programming language, the program utilizes a main function that calls upon an methods contained in independent library\footnote{These files are not a formal \texttt{C++} ``library,'' but do behave like one.}.  This library can easily be utilized by a different main function with equal success.  A new simulator obeying a different partial differential equation can be produced inheriting from a \texttt{Simulator} class and overloading the \texttt{apply\_step} function.  Likewise, the boundary conditions are easily changed by overloading the \texttt{get\_cell} function.  In order to ensure there are no clashes with existing libraries, the simulator defines its own namespace, \texttt{PUMA}.  These properties ensure this library is reusable, extendable, and self contained.  

\subsubsection{Complier}

The simulation was compiled with \texttt{gcc} version 4.6, which is the most widely available version on current \texttt{Linux} distributions.  This is to ensure that the program can run on many platforms.  Unfortunately, only the features of \texttt{C++11} implemented in this version of \texttt{gcc} were used.  For example, the newer version of \texttt{gcc}, version 4.8, supports constructor inheritance, which would have been useful in defining the constructors in \texttt{exceptions.hpp}.  Instead, a constructor and destructor needed to be defined for each exception. 

%SOMETHING ELSE

\subsubsection{Boost}

\texttt{Boost} is one of the most widely used, reviewed, and tested \texttt{C++} libraries.  It greatly improved the memory management, parsing methods, and standard functions  available to the simulation.   It also provided a unit testing framework, as discussed in Section \ref{test}.  

To improve memory management, \texttt{boost::shared\_array} was used.  This object is an instance of a \emph{smart pointer}.  Smart pointers ensure that an object is automatically removed from memory once all references to that object go out of scope.  This is to say that once all smart pointers to an object are no longer available to the simulation, this object is removed from memory.  This property is especially useful when dealing with the large arrays found in \texttt{Simulator.cpp}.  
%Additionally, the \texttt{swap} function of the \texttt{shared\_array} was very useful in the \texttt{apply\_step} function.  This function swaps the address of two 

Using \texttt{Boost}, the program options can be defined, grouped, and easily set at runtime.  This library also enables configuration files to be used with little added code.  The program options are also conveniently stored and displayed in a help menu, which can also be displayed at runtime.  

Finally, the \texttt{Boost} was used to define a Mersenne-Twister random number generator.  This random number generator is seeded with the current time up to a microsecond.  This is to ensure a unique seed for all simulator classes, even when they are instantiated within a small time frame.  The Mersenne-Twister generator more random, long period, and because it is widely tested and used.  (REF)

\subsection{Build}

In order to build the simulation, a \texttt{Makefile} must be generated.  \texttt{CMake} was used to abstract this process, ensuring that it is as system independent as possible.   This is done using \texttt{find} scripts, which only require the user to supply the names the needed include files.  The paths to these files are determined, and printed to the \texttt{Makefile}.  Additionally, \texttt{CMake} prints the the build process, detailing the progress and any errors. (REF) %Minus:  Requires installation of CMake 2.8, ex: not available in scilinux 

\subsection{Revision Control}

The revision control software \texttt{git} was used to streamline group editing of the source code and coordinate efforts between group members.  This software based on a decentralized repository structure, which is favorable to a centralized repository structure.  By decentralizing, the development no longer has a single point of failure.  In addition, decentralized structures allow for easy write privilege management and allow changes can be committed offline.

\texttt{git} was chosen over the popular decentralized alternatives because it is the mostly widely supported and fasted available.  Using \texttt{git} meant that the free online repository \texttt{GitHub} could be used.  Using this software, changes could be tracked and visualized.  It was one of the most important lines of communication between group members.


\subsection{Testing}\label{test}

All unit testing was done with \texttt{boost::UNIT\_TEST}.  This library is included in \texttt{boost} and provides the basic functionality needed for the program.  Tests were included in a \texttt{test\_suite.cpp} file.  The first of these tests ensure that the simulator can be constructed and that the land map is parsed correctly.  The next set ensures that the \texttt{apply\_step} function effects the populations of the land cells, but do not effect the populations of the water cells.  To test the output, the \texttt{test\_suite} turns off all birth and death rate terms to ensure the diffusion of populations works correctly.   

Performance profiling was used to optimize the simulation.  This profiling was done with \texttt{Valgrind} using the \texttt{Callgrind} tool.  This tool provided an estimate of the time spent on each function.  The \texttt{Kcachegrind} tool visualized this information, as shown below in \ref{fig:pref}.

%INSERT FIG PREF

The performance profiling reveal that 95\% of the computation was devoted to printing the output, with less than 1\% spent on \texttt{apply\_step}.  This motivated the group to decrease the default time step and print frequency by a factor of 100.  This greatly improved the accuracy of the simulation without significantly increasing the computation time.  

\subsection{Debugging}

The simulation was debugged using \texttt{gdb}.  In order to do so, the program was compiled with the \texttt{-g} flag.  By setting break points, the components simulation were compartmentalized so that sources of error could found.  For example, the \texttt{halo\_cell} structure was not properly instantiated the first time.  A break point allowed the group to review the contents of the cell before the program crashed, revealing this error.   

To ensure that there were no memory leaks in the program, the \texttt{memcheck} tool from \texttt{Valgrind} was used.  This tool revealed that boolean \texttt{land\_map} array was not destructed after it had been parsed to \texttt{current\_state} and \texttt{temp\_state}.  
 
 \subsection{Documentation}

 
 \section{Analysis}
 
 \subsection{Testing}
Performance tests and analysis Description on the performance experiments you did and an analysis
of the results of these.

stabilization of decreasing time step
 
 
 \section{Conclusion}
Conclusions Some brief conclusions.
 
\subsection{Further Works}
 Ideas for further work, or what you would have done if you had had more time.

\end{document}


\bibliography{references}{}
\bibliographystyle{unsrt}


%TO DO
%  reobserve nLand param in apply_step.  has same name in averages
%  discretize equations
% HOW TO USE PROGRAM appendix
% 

